{"version":3,"file":"bulkfamilyupload.min.js","sources":["../src/bulkfamilyupload.js"],"sourcesContent":["// This file is part of FLIP Plugins for Moodle\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * JavaScript for bulk family upload functionality.\n *\n * @module     local_equipment/bulkfamilyupload\n * @copyright  2024 Joshua Kirby <josh@funlearningcompany.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport $ from 'jquery';\nimport { get_string as getString } from 'core/str';\nimport Log from 'core/log';\n// import { get } from 'grunt';\n\n/**\n * Initialize the module.\n */\nexport const init = () => {\n    const $textarea = $('#id_familydata');\n    const $preprocessDiv = $('#family-preprocess-display');\n    const $preprocessButton = $('.preprocessbutton');\n    const $submitButton = $('#id_submitbutton');\n    const $partnershipData = $('#id_partnershipdata');\n    const partnershipDataValue = JSON.parse(\n        $partnershipData.attr('data-partnerships')\n    );\n    const $courseData = $('#id_coursedata');\n    const courseDataValue = JSON.parse($courseData.attr('data-courses'));\n\n    // Set initial height of preprocess div to match textarea\n    $preprocessDiv.css('height', $textarea.outerHeight() + 'px');\n\n    // Disable submit button when textarea content changes\n    $textarea.on('input', () => {\n        $submitButton.prop('disabled', true);\n    });\n\n    // Function to clean up input text\n    const cleanInputText = (text) => {\n        // Trim newlines and whitespace from the start and end of the entire input\n        return text.replace(/^\\s+|\\s+$/g, '');\n    };\n\n    $preprocessButton.on('click', async (e) => {\n        e.preventDefault(); // Prevent form submission\n\n        // Clean up input text\n\n        try {\n            $textarea.val(cleanInputText($textarea.val()));\n            const data = {\n                input: $textarea.val(),\n                partnerships: partnershipDataValue,\n                courses: courseDataValue,\n            };\n\n            const families = await validateFamilyData(data);\n\n            Log.debug('families: ');\n            Log.debug(families);\n            $preprocessDiv.html(families.html);\n\n            // Adjust height of preprocess div to match textarea\n            $preprocessDiv.css('height', $textarea.outerHeight() + 'px');\n\n            // Enable the submit button if there are no error messages\n            const hasErrors = families.html.includes('alert-danger');\n            $submitButton.prop('disabled', hasErrors);\n\n            const messageKey = hasErrors\n                ? 'preprocessing_failure'\n                : 'preprocessing_success';\n            const message = await getString(messageKey, 'local_equipment');\n            Log.debug(message);\n        } catch (error) {\n            Log.error('Error in preprocessing: ');\n            Log.error(error);\n            $submitButton.prop('disabled', true);\n            const errorMessage = await getString(\n                'errorvalidatingfamilydata',\n                'local_equipment'\n            );\n            Log.debug(errorMessage);\n        }\n    });\n\n    // Adjust preprocess div height on window resize\n    $(window).on('resize', () => {\n        $preprocessDiv.css('height', $textarea.outerHeight() + 'px');\n    });\n};\n\n/**\n * Validate and process family data.\n *\n * @param {Object} data - The input data object.\n * @param {string} data.input - The raw input string containing family data.\n * @param {Object} data.partnerships - Partnership data keyed by ID.\n * @param {Object} data.courses - Course data keyed by ID.\n * @return {Promise<string>} The HTML feedback string.\n */\nexport const validateFamilyData = async ({ input, partnerships, courses }) => {\n    let familiesData = [];\n    let familiesHTML = [];\n    Log.debug('input: ');\n    Log.debug(input);\n    // Log.debug(partnerships);\n    // Log.debug(courses);\n    if (!input || typeof input !== 'string') {\n        throw new Error(\n            getString(\n                'invalidinput',\n                'local_equipment',\n                getString('expectedanonemptystring', 'local_equipment')\n            )\n        );\n    }\n    // This creates and objext with text types as keys and regexes to match as values.\n    const regexes = {\n        email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n        phone: /^(\\+?\\d{1,2}\\s?)?(\\(?\\d{3}\\)?[\\s.-]?)?\\d{3}[\\s.-]?\\d{4}$/,\n        name: /^[a-zA-Z\\s'-]+$/,\n        partnership: /^-?\\d+$/,\n        student: /^\\*(?!\\*)(.)/,\n        courses: /^\\*\\*.*$/,\n    };\n\n    /**\n     * Determine the type of text based on regex patterns.\n     * Below, we are defining a function that will take the above oject using and convert it into an array of key/values.\n     * So instead of having an object like this:\n     * textType1: /regex1/\n     * textType2: /regex2/\n     * textType3: /regex3/\n     * textType4: /regex4/\n     * We will have only the one matched key/value pair returned in the form of an array like this:\n     * ['textTypeX', /regexX/]\n     * ('X' representing whichever key/value pair was matched).\n     * It's the Object.entries(regexes) function that does all that. Then, the find() function comes in.\n     * The find() function, in this case, destuctures the array that was returned by Object.entries(regexes), skipping the first\n     * element (the key) and assigning the second element (the value) to the variable 'regex', which has the test() function.\n     *\n     * Returns the key of the first element in the array that matches the regex.\n     * So, determineTextType() should return one of the following:\n     * 'email'\n     * 'phone'\n     * 'name'\n     * 'partnership'\n     * 'student'\n     * 'courses'\n     * 'unknown'\n     *\n     * @param {string} line - The line of text to analyze.\n     * @return {string} The determined text type.\n     */\n    const determineTextType = (line) => {\n        for (const [type, regex] of Object.entries(regexes)) {\n            if (regex.test(line)) {\n                if (type === 'phone' && line.length < 10) {\n                    return 'unknown';\n                }\n                return type;\n            }\n        }\n        return 'unknown';\n    };\n\n    /**\n     * Parse and reformat a phone number into +12345678910 format.\n     * Take any phone number, and turn it into a U.S. phone number.\n     * E.g +1 (234) 567-8910 -> +12345678910\n     * E.g. 234-567-8910 -> +12345678910\n     * E.g. 234.567.8910 -> +12345678910\n     * E.g. 234 567 8910 -> +12345678910\n     * E.g. 2345678910 -> +12345678910\n     * E.g. 12345678910 -> +12345678910\n     * @param {string} phoneNumber - The phone number to reformat.\n     * @return {Object} An object containing the reformatted phone number and any errors.\n     */\n    const parsePhoneNumber = async (phoneNumber) => {\n        let parsedPhoneNumber = phoneNumber.replace(/[()\\-\\s+.]/g, '');\n        if (parsedPhoneNumber.length === 10 && parsedPhoneNumber[0] !== '1') {\n            parsedPhoneNumber = '+1' + parsedPhoneNumber;\n        } else if (\n            parsedPhoneNumber.length === 11 &&\n            parsedPhoneNumber[0] === '1'\n        ) {\n            parsedPhoneNumber = '+' + parsedPhoneNumber;\n        } else {\n            return (\n                '<span class=\"pl-2 pr-2 alert-danger\">' +\n                (await getString(\n                    'invalidphonenumber',\n                    'local_equipment',\n                    parsedPhoneNumber\n                )) +\n                '</span>'\n            );\n        }\n        return parsedPhoneNumber;\n    };\n\n    /**\n     * Process parent information from a line of text.\n     *\n     * @param {string} line - The line of text to process.\n     * @param {string} textType - The type of text determined.\n     * @param {Object} parent - The current parent object.\n     * @return {Object} Updated parent object.\n     */\n    const processParentInfo = async (line, textType, parent) => {\n        // let parentObj = {\n        //     name: {\n        //         html: '',\n        //         data: '',\n        //     },\n        //     phone: {\n        //         html: '',\n        //         data: '',\n        //     },\n        //     email: {\n        //         html: '',\n        //         data: '',\n        //     },\n        // };\n        parent = {\n            ...parent,\n            [textType]: {\n                html: line,\n                data: line,\n            },\n        };\n        // parentObj[textType] = {\n        //     html: line,\n        //     data: line,\n        // };\n        // Log.debug('parent stuff: ');\n        // Log.debug(textType);\n        // Log.debug(line);\n        switch (textType) {\n            // case 'name':\n            //     break;\n            case 'email':\n                parent[textType].html =\n                    '<span class=\"pl-4 pr-4\">' + line + '</span>';\n                // parentObj = {\n                //     line: '<span class=\"pl-4 pr-4\">' + line + '</span>',\n                //     parent: { ...parent, [textType]: line },\n                //     partnership,\n                // };\n                break;\n            case 'phone': {\n                let formattedPhone = await parsePhoneNumber(line);\n                parent[textType].data = formattedPhone;\n                parent[textType].html =\n                    '<span class=\"pl-4 pr-4\">' + formattedPhone + '</span>';\n                break;\n\n                // return {\n                //     line: '<span class=\"pl-4 pr-4\">' + line + '</span>',\n                //     parent: { ...parent, [textType]: line },\n                //     partnership,\n                // };\n            }\n            default:\n                // return { parent, partnership };\n                break;\n        }\n        return parent;\n    };\n\n    /**\n     * Process student information from a line of text.\n     *\n     * @param {string} line - The line of text to process.\n     * @param {string} textType - The type of text determined.\n     * @param {Object} student - The current student object.\n     * @return {Object} Updated student object.\n     */\n    const processStudentInfo = async (line, textType, student) => {\n        student = {\n            ...student,\n            [textType]: {\n                html: line,\n                data: line,\n            },\n        };\n\n        switch (textType) {\n            case 'student': {\n                // This refers to the student's name, which is the only line that is preceded by a single asterisk (*).\n                const name = line.replace('*', '').trim();\n                student[textType].data = name;\n                student[textType].html = name;\n\n                // return { ...student, name, line: name };\n                break;\n            }\n            case 'email':\n                student[textType].data = line;\n                student[textType].html =\n                    '<span class=\"pl-4 pr-4\">' + line + '</span>';\n                // return {\n                //     line: '<span class=\"pl-4 pr-4\">' + line + '</span>',\n                //     student: { ...student, [textType]: line },\n                // };\n                break;\n            case 'phone': {\n                let formattedPhone = await parsePhoneNumber(line);\n                student[textType].data = formattedPhone;\n                student[textType].html =\n                    '<span class=\"pl-4 pr-4\">' + formattedPhone + '</span>';\n                break;\n            }\n            case 'courses': {\n                // student[textType].data =\n\n                const coursesData = line\n                    .replace('**', '')\n                    .trim()\n                    .split(',')\n                    .map((course) => course.trim());\n\n                // courseIds.map(async (id) => {\n                //     student[textType] = {\n                //         ...student[textType],\n                //             html: line,\n                //             data: line,\n                //     };\n                // });\n                // let coursesHTML = '';\n\n                const coursesHTML = await Promise.all(\n                    coursesData.map(async (id) => {\n                        let courseName = '';\n                        if (courses[id]) {\n                            const enDash = 'â€“'; // EN DASH character\n                            const regex = new RegExp(`${id} ${enDash} `, 'g');\n                            courseName = courses[id].replace(regex, '');\n                        } else {\n                            const errorMessage = await getString(\n                                'idnotfound',\n                                'local_equipment',\n                                id\n                            );\n                            courseName = `<span class=\"pl-2 pr-2 alert-danger\">${errorMessage}</span>`;\n                        }\n\n                        Log.debug('courseName: ', courseName);\n                        Log.debug('id: ', id);\n\n                        return courseName;\n                    })\n                ).join(', ');\n\n                // Log.debug('studentCourses: ', studentCourses);\n\n                // return {\n                //     student: { ...student, courses: studentCourses },\n                //     line: `<span class=\"pl-4 pr-4\">${studentCourses.join(\n                //         ', '\n                //     )}</span>`,\n                // };\n                student[textType].data = coursesData;\n                student[textType].html = coursesHTML;\n                break;\n            }\n            default:\n                break;\n        }\n        return student;\n    };\n\n    /**\n     * Process partnership information from a line of text.\n     *\n     * @param {string} id - The partnership ID.\n     * @return {Object} The partnership object.\n     */\n\n    const processPartnershipInfo = async (id) => {\n        let partnership = {};\n        if (partnerships[id]) {\n            partnership = {\n                data: id,\n                html: partnerships[id],\n            };\n        } else {\n            partnership = {\n                data: id,\n                html:\n                    '<span class=\"pl-2 pr-2 alert-danger\">' +\n                    (await getString(\n                        'partnershipnumbernotfound',\n                        'local_equipment',\n                        id\n                    )) +\n                    '</span>',\n            };\n        }\n\n        return {\n            partnership,\n            inStudentSection: true,\n        };\n    };\n\n    /**\n     * Process a single family's data, a.k.a. a family chunk.\n     * This const will be used as input for the map() function below.\n     *\n     * @param {string} family - The raw family data string.\n     * @return {string} HTML feedback for the family.\n     */\n    const processFamily = async (family) => {\n        Log.debug('Processing family...');\n\n        let parents = [];\n        let students = [];\n        let parent = {};\n        let student = {};\n        let partnership = {};\n        let inStudentSection = false;\n        let familyData = {};\n        let familyHTML = []; // The will be joined into a single string at the end.\n\n        let partnershipAdded = false;\n\n        // Grab each family chunk and split each line into its own element within the 'lines' array.\n        const promiseResults = await Promise.all(\n            family.split('\\n').map(async (line) => {\n                Log.debug('Processing family... mapping...');\n                line.trim();\n                const textType = determineTextType(line);\n\n                if (textType === 'student') {\n                    inStudentSection = true;\n                }\n\n                // Determine whether we're in the student section, parent section, or an unknown section.\n                if (textType === 'unknown') {\n                    const errorString = await getString(\n                        'unrecognizedformat',\n                        'local_equipment',\n                        line\n                    );\n                    familyHTML.push(\n                        `<span class=\"pl-2 alert-danger\">${errorString}</span>`\n                    );\n                    // The 'familyData' object won't need anything added, 'cause we're checking for errors using 'alert-danger'.\n                } else if (partnershipAdded && textType === 'partnership') {\n                    const errorString = await getString(\n                        'connotaddmorethanonepartnership',\n                        'local_equipment',\n                        line\n                    );\n                    familyHTML.push(\n                        `<span class=\"pl-2 alert-danger\">${errorString}</span>`\n                    );\n                } else if (textType === 'partnership') {\n                    ({ partnership, inStudentSection } =\n                        await processPartnershipInfo(line));\n                    familyHTML.push(partnership.html);\n                    // There can only be one partnership\n                    familyData.partnership = partnership.data;\n                    partnershipAdded = true;\n                } else if (!inStudentSection) {\n                    // We haven't entered the student section yet.\n                    ({ parent } = await processParentInfo(\n                        line,\n                        textType,\n                        parent\n                    ));\n\n                    // The 'email' line marks the end of a given parent, so we push the parent object to the 'parents' array.\n                    if (textType === 'email') {\n                        parents.push(parent);\n                        parent = {};\n                    }\n                    familyHTML.push(parent[textType].html);\n                } else {\n                    // Now we are in the student section.\n                    ({ student } = await processStudentInfo(\n                        line,\n                        textType,\n                        student\n                    ));\n                    // line = student[textType].html;\n                    if (textType === 'courses') {\n                        students.push(student);\n                        student = {};\n                    }\n                    familyHTML.push(student[textType].html);\n                }\n\n                // We're using this map function to change and update the variables above, so we don't need to return anything.\n            })\n        );\n\n        // for (let line of lines) {\n        //     const textType = determineTextType(line);\n\n        //     // Log.debug('line ' + line + ' is of type ' + textType);\n        //     // Log.debug(partnership);\n\n        //     if (textType === 'student') {\n        //         inStudentSection = true;\n        //     }\n\n        //     // Determine whether we're in the student section, parent section, or an unknown section.\n        //     if (textType === 'unknown') {\n        //         const errorString = await getString(\n        //             'unrecognizedformat',\n        //             'local_equipment',\n        //             line\n        //         );\n        //         familyHTML.push(\n        //             `<span class=\"pl-2 alert-danger\">${errorString}</span>`\n        //         );\n        //     } else if (textType === 'partnership') {\n        //         ({ partnership, inStudentSection } =\n        //             await processPartnershipInfo(line));\n        //         familyHTML.push(partnership.html);\n        //         familyData.partnership = partnership.data;\n        //     } else if (!inStudentSection) {\n        //         // We haven't entered the student section yet.\n        //         ({ parent } = await processParentInfo(line, textType, parent));\n\n        //         // The 'email' line marks the end of a given parent, so we push the parent object to the 'parents' array.\n        //         if (textType === 'email') {\n        //             parents.push(parent);\n        //             parent = {};\n        //         }\n        //         familyHTML.push(parent[textType].html);\n        //     } else {\n        //         // Now we are in the student section.\n        //         ({ student } = await processStudentInfo(\n        //             line,\n        //             textType,\n        //             student\n        //         ));\n        //         // line = student[textType].html;\n        //         if (textType === 'courses') {\n        //             students.push(student);\n        //             student = {};\n        //         }\n        //         familyHTML.push(student[textType].html);\n        //     }\n\n        //     // if (textType !== 'unknown') {\n        //     //     familyHTML.push(line);\n        //     // }\n        // }\n\n        Log.debug('promiseResults: ');\n        Log.debug(promiseResults);\n\n        familyData = { parents, students, partnership };\n        familiesData.push(familyData);\n        familyHTML = `<div class=\"bg-light border p-3\">${familyHTML.join(\n            '<br />'\n        )}</div>`;\n        familiesHTML.push(familyHTML);\n\n        return familyHTML;\n    };\n\n    // Separate the families into individual family chunks and trim.\n    const familiesInput = input.split('\\n\\n').filter((family) => family.trim());\n\n    familiesHTML = await Promise.all(familiesInput.map(processFamily));\n\n    Log.debug('family stuff: ');\n    Log.debug(familiesData);\n    Log.debug(familiesHTML);\n    Log.debug(familiesInput);\n    // Log.debug(preprocessPromises);\n    // Log.debug(preprocessResults);\n    Log.debug(familiesHTML);\n\n    return {\n        data: familiesData,\n        html: familiesHTML.join('<br>'),\n    };\n};\n"],"names":["$textarea","$preprocessDiv","$preprocessButton","$submitButton","$partnershipData","partnershipDataValue","JSON","parse","attr","$courseData","courseDataValue","css","outerHeight","on","prop","async","e","preventDefault","val","replace","data","input","partnerships","courses","families","validateFamilyData","debug","html","hasErrors","includes","messageKey","message","error","errorMessage","window","familiesData","familiesHTML","Error","regexes","email","phone","name","partnership","student","parsePhoneNumber","parsedPhoneNumber","phoneNumber","length","familiesInput","split","filter","family","trim","Promise","all","map","parents","students","parent","inStudentSection","familyData","familyHTML","partnershipAdded","promiseResults","line","textType","type","regex","Object","entries","test","determineTextType","errorString","push","id","processPartnershipInfo","formattedPhone","coursesData","course","coursesHTML","courseName","enDash","RegExp","join","processStudentInfo","processParentInfo"],"mappings":"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"}