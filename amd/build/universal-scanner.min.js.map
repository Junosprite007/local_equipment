{"version":3,"file":"universal-scanner.min.js","sources":["../src/universal-scanner.js"],"sourcesContent":["// This file is part of FLIP Plugins for Moodle\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Universal barcode scanner for QR codes and UPC/EAN barcodes.\n *\n * @module     local_equipment/universal-scanner\n * @copyright  2024 onwards Joshua Kirby <josh@funlearningcompany.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Ajax from 'core/ajax';\nimport Log from 'core/log';\nimport jsQR from 'local_equipment/jsqr';\n\n/**\n * Universal scanner class for handling QR codes and UPC/EAN barcodes.\n */\nexport default class UniversalScanner {\n    /**\n     * Constructor for UniversalScanner.\n     *\n     * @param {Object} options Scanner configuration options\n     */\n    constructor(options = {}) {\n        this.options = {\n            containerId: 'scanner-container',\n            videoId: 'scanner-video',\n            canvasId: 'scanner-canvas',\n            resultCallback: null,\n            errorCallback: null,\n            scanTypes: ['auto'], // Auto, qr, upc\n            timeout: 30000,\n            ...options,\n        };\n\n        this.isScanning = false;\n        this.stream = null;\n        this.video = null;\n        this.canvas = null;\n        this.context = null;\n        this.sessionId = this.generateSessionId();\n        this.scanAttempts = 0;\n        this.maxScanAttempts = 50;\n\n        // Bind methods\n        this.startScanning = this.startScanning.bind(this);\n        this.stopScanning = this.stopScanning.bind(this);\n        this.processFrame = this.processFrame.bind(this);\n    }\n\n    /**\n     * Initialize the scanner interface.\n     *\n     * @returns {Promise} Promise that resolves when scanner is ready\n     */\n    async init() {\n        try {\n            await this.setupInterface();\n            await this.checkCameraSupport();\n            return true;\n        } catch (error) {\n            this.handleError('init_failed', error.message);\n            return false;\n        }\n    }\n\n    /**\n     * Setup the scanner interface elements.\n     */\n    async setupInterface() {\n        const container = document.getElementById(this.options.containerId);\n        if (!container) {\n            throw new Error(\n                `Container element ${this.options.containerId} not found`\n            );\n        }\n\n        // Create video element\n        this.video = document.createElement('video');\n        this.video.id = this.options.videoId;\n        this.video.setAttribute('playsinline', true);\n        this.video.setAttribute('autoplay', true);\n        this.video.setAttribute('muted', true);\n        this.video.style.width = '100%';\n        this.video.style.height = 'auto';\n\n        // Create canvas for frame processing\n        this.canvas = document.createElement('canvas');\n        this.canvas.id = this.options.canvasId;\n        this.canvas.style.display = 'none';\n        this.context = this.canvas.getContext('2d', {\n            willReadFrequently: true,\n        });\n\n        // Add elements to container\n        container.appendChild(this.video);\n        container.appendChild(this.canvas);\n\n        // Add scan overlay\n        this.createScanOverlay(container);\n    }\n\n    /**\n     * Create scanning overlay with target box.\n     *\n     * @param {HTMLElement} container Container element\n     */\n    createScanOverlay(container) {\n        const overlay = document.createElement('div');\n        overlay.className = 'scanner-overlay';\n        overlay.innerHTML = `\n            <div class=\"scan-target\">\n                <div class=\"scan-corners\">\n                    <div class=\"corner top-left\"></div>\n                    <div class=\"corner top-right\"></div>\n                    <div class=\"corner bottom-left\"></div>\n                    <div class=\"corner bottom-right\"></div>\n                </div>\n                <div class=\"scan-line\"></div>\n            </div>\n            <div class=\"scan-instructions\">\n                <p>Position barcode or QR code within the frame</p>\n                <div class=\"scan-status\">Ready to scan</div>\n            </div>\n        `;\n\n        container.appendChild(overlay);\n        this.overlay = overlay;\n    }\n\n    /**\n     * Check if camera access is supported.\n     *\n     * @returns {Promise<boolean>} True if camera is supported\n     */\n    async checkCameraSupport() {\n        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n            throw new Error('Camera access not supported in this browser');\n        }\n\n        // Check for BarcodeDetector API support\n        this.hasBarcodeDetector = 'BarcodeDetector' in window;\n\n        return true;\n    }\n\n    /**\n     * Start scanning for barcodes.\n     *\n     * @returns {Promise} Promise that resolves when scanning starts\n     */\n    async startScanning() {\n        if (this.isScanning) {\n            return;\n        }\n\n        try {\n            this.updateStatus('Requesting camera access...');\n\n            // Request camera access\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    facingMode: 'environment', // Prefer rear camera\n                    width: { ideal: 1280 },\n                    height: { ideal: 720 },\n                },\n            });\n\n            this.video.srcObject = this.stream;\n            await this.video.play();\n\n            // Set canvas dimensions to match video\n            this.canvas.width = this.video.videoWidth;\n            this.canvas.height = this.video.videoHeight;\n\n            this.isScanning = true;\n            this.scanAttempts = 0;\n            this.updateStatus('Scanning...');\n\n            // Start scanning loop\n            this.scanLoop();\n        } catch (error) {\n            this.handleError('camera_access_failed', error.message);\n        }\n    }\n\n    /**\n     * Stop scanning and release camera.\n     */\n    stopScanning() {\n        this.isScanning = false;\n\n        if (this.stream) {\n            this.stream.getTracks().forEach((track) => track.stop());\n            this.stream = null;\n        }\n\n        if (this.video) {\n            this.video.srcObject = null;\n        }\n\n        this.updateStatus('Scanner stopped');\n    }\n\n    /**\n     * Main scanning loop.\n     */\n    async scanLoop() {\n        if (!this.isScanning) {\n            return;\n        }\n\n        try {\n            await this.processFrame();\n            this.scanAttempts++;\n\n            // Check if we've exceeded max attempts\n            if (this.scanAttempts >= this.maxScanAttempts) {\n                this.updateStatus('Scan timeout - please try again');\n                setTimeout(() => {\n                    this.scanAttempts = 0;\n                    this.updateStatus('Scanning...');\n                }, 2000);\n            }\n        } catch (error) {\n            // Continue scanning even if frame processing fails\n            Log.debug('Frame processing error:', error);\n        }\n\n        // Continue scanning\n        if (this.isScanning) {\n            requestAnimationFrame(() => this.scanLoop());\n        }\n    }\n\n    /**\n     * Process current video frame for barcodes.\n     */\n    async processFrame() {\n        if (\n            !this.video ||\n            this.video.readyState !== this.video.HAVE_ENOUGH_DATA\n        ) {\n            return;\n        }\n\n        // Draw current frame to canvas\n        this.context.drawImage(\n            this.video,\n            0,\n            0,\n            this.canvas.width,\n            this.canvas.height\n        );\n\n        // Try native BarcodeDetector first (Chrome/Edge)\n        if (this.hasBarcodeDetector) {\n            try {\n                // eslint-disable-next-line no-undef\n                const detector = new BarcodeDetector({\n                    formats: [\n                        'qr_code',\n                        'ean_13',\n                        'ean_8',\n                        'upc_a',\n                        'upc_e',\n                        'code_128',\n                        'code_39',\n                    ],\n                });\n\n                const barcodes = await detector.detect(this.canvas);\n\n                if (barcodes.length > 0) {\n                    const barcode = barcodes[0];\n                    await this.processScanResult(\n                        barcode.rawValue,\n                        barcode.format\n                    );\n                    return;\n                }\n            } catch (error) {\n                // Fall back to manual processing\n                Log.debug('BarcodeDetector failed:', error);\n            }\n        }\n\n        // Fallback: Try to detect QR codes manually using image data\n        await this.detectQRCodeManually();\n    }\n\n    /**\n     * Manual QR code detection fallback.\n     */\n    async detectQRCodeManually() {\n        try {\n            const imageData = this.context.getImageData(\n                0,\n                0,\n                this.canvas.width,\n                this.canvas.height\n            );\n\n            // Use jsQR library for QR code detection\n            const code = jsQR.scan(\n                imageData.data,\n                imageData.width,\n                imageData.height\n            );\n\n            if (code && code.data) {\n                await this.processScanResult(code.data, 'qr_code');\n            }\n        } catch (error) {\n            // Silently fail - this is just a fallback method\n            Log.debug('Manual QR detection failed:', error);\n        }\n    }\n\n    /**\n     * Process a successful scan result.\n     *\n     * @param {string} data Scanned barcode data\n     * @param {string} format Barcode format\n     */\n    async processScanResult(data, format) {\n        if (!data || data.trim() === '') {\n            return;\n        }\n\n        this.updateStatus('Processing scan...');\n        this.isScanning = false; // Stop scanning while processing\n\n        try {\n            // Determine scan type\n            let scanType = 'auto';\n            if (format === 'qr_code') {\n                scanType = 'qr';\n            } else if (['ean_13', 'ean_8', 'upc_a', 'upc_e'].includes(format)) {\n                scanType = 'upc';\n            }\n\n            Log.debug('Processing scan result:', {\n                data: data,\n                format: format,\n                scanType: scanType,\n            });\n\n            // For add-items page, bypass web service and call callback directly\n            if (this.options.resultCallback) {\n                const result = {\n                    success: true,\n                    data: {\n                        barcode_data: data,\n                        scan_type: scanType,\n                        format: format,\n                    },\n                    timestamp: Date.now(),\n                };\n\n                this.updateStatus('Scan successful!');\n                this.showScanSuccess();\n                this.options.resultCallback(result);\n                return;\n            }\n\n            // Fallback: Send to server for processing (for other pages)\n            const result = await this.sendScanToServer(data, scanType);\n\n            if (result.success) {\n                this.updateStatus('Scan successful!');\n                this.showScanSuccess();\n\n                // Call result callback if provided\n                if (this.options.resultCallback) {\n                    this.options.resultCallback(result);\n                }\n            } else {\n                this.handleScanError(result);\n            }\n        } catch (error) {\n            this.handleError('processing_failed', error.message);\n        }\n    }\n\n    /**\n     * Send scan data to server for processing.\n     *\n     * @param {string} barcodeData Scanned barcode data\n     * @param {string} scanType Type of scan (qr, upc, auto)\n     * @returns {Promise<Object>} Server response\n     */\n    async sendScanToServer(barcodeData, scanType) {\n        const request = {\n            methodname: 'local_equipment_process_scan',\n            args: {\n                barcode_data: barcodeData,\n                scan_type: scanType,\n                session_id: this.sessionId,\n            },\n        };\n\n        const response = await Ajax.call([request])[0];\n        return response;\n    }\n\n    /**\n     * Handle scan error from server.\n     *\n     * @param {Object} result Error result from server\n     */\n    handleScanError(result) {\n        const errorMessages = {\n            empty_barcode: 'No barcode data detected',\n            invalid_uuid: 'Invalid QR code format',\n            item_not_found: 'Equipment item not found',\n            product_not_found: 'Product not found in database',\n            unknown_type: 'Unknown barcode type',\n        };\n\n        const message =\n            errorMessages[result.error_code] || result.message || 'Scan failed';\n        this.updateStatus(`Error: ${message}`);\n\n        // Resume scanning after error\n        setTimeout(() => {\n            this.isScanning = true;\n            this.updateStatus('Scanning...');\n        }, 2000);\n    }\n\n    /**\n     * Handle general errors.\n     *\n     * @param {string} errorCode Error code\n     * @param {string} message Error message\n     */\n    handleError(errorCode, message) {\n        Log.error(`Scanner error [${errorCode}]:`, message);\n        this.updateStatus(`Error: ${message}`);\n\n        if (this.options.errorCallback) {\n            this.options.errorCallback(errorCode, message);\n        }\n    }\n\n    /**\n     * Update status display.\n     *\n     * @param {string} message Status message\n     */\n    updateStatus(message) {\n        const statusElement = document.querySelector('.scan-status');\n        if (statusElement) {\n            statusElement.textContent = message;\n        }\n    }\n\n    /**\n     * Show scan success animation.\n     */\n    showScanSuccess() {\n        const target = document.querySelector('.scan-target');\n        if (target) {\n            target.classList.add('scan-success');\n            setTimeout(() => {\n                target.classList.remove('scan-success');\n            }, 1000);\n        }\n    }\n\n    /**\n     * Generate unique session ID.\n     *\n     * @returns {string} Session ID\n     */\n    generateSessionId() {\n        return (\n            'scan_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)\n        );\n    }\n\n    /**\n     * Process file upload for barcode scanning.\n     *\n     * @param {File} file Image file to process\n     * @returns {Promise} Promise that resolves with scan result\n     */\n    async processFileUpload(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n\n            reader.onload = async (e) => {\n                try {\n                    const img = new Image();\n                    img.onload = async () => {\n                        // Draw image to canvas\n                        this.canvas.width = img.width;\n                        this.canvas.height = img.height;\n                        this.context.drawImage(img, 0, 0);\n\n                        // Try to detect barcodes\n                        if (this.hasBarcodeDetector) {\n                            try {\n                                // eslint-disable-next-line no-undef\n                                const detector = new BarcodeDetector({\n                                    formats: [\n                                        'qr_code',\n                                        'ean_13',\n                                        'ean_8',\n                                        'upc_a',\n                                        'upc_e',\n                                    ],\n                                });\n\n                                const barcodes = await detector.detect(\n                                    this.canvas\n                                );\n\n                                if (barcodes.length > 0) {\n                                    const result = await this.processScanResult(\n                                        barcodes[0].rawValue,\n                                        barcodes[0].format\n                                    );\n                                    resolve(result);\n                                } else {\n                                    reject(\n                                        new Error('No barcode found in image')\n                                    );\n                                }\n                            } catch (error) {\n                                reject(error);\n                            }\n                        } else {\n                            reject(\n                                new Error('Barcode detection not supported')\n                            );\n                        }\n                    };\n\n                    img.src = e.target.result;\n                } catch (error) {\n                    reject(error);\n                }\n            };\n\n            reader.onerror = () => reject(new Error('Failed to read file'));\n            reader.readAsDataURL(file);\n        });\n    }\n\n    /**\n     * Process manual barcode entry.\n     *\n     * @param {string} barcodeData Manually entered barcode\n     * @param {string} scanType Type of scan\n     * @returns {Promise} Promise that resolves with scan result\n     */\n    async processManualEntry(barcodeData, scanType = 'auto') {\n        try {\n            this.updateStatus('Processing manual entry...');\n            const result = await this.sendScanToServer(barcodeData, scanType);\n\n            if (result.success) {\n                this.updateStatus('Manual entry successful!');\n                if (this.options.resultCallback) {\n                    this.options.resultCallback(result);\n                }\n            } else {\n                this.handleScanError(result);\n            }\n\n            return result;\n        } catch (error) {\n            this.handleError('manual_entry_failed', error.message);\n            throw error;\n        }\n    }\n\n    /**\n     * Destroy scanner and clean up resources.\n     */\n    destroy() {\n        this.stopScanning();\n\n        // Remove elements\n        if (this.video && this.video.parentNode) {\n            this.video.parentNode.removeChild(this.video);\n        }\n\n        if (this.canvas && this.canvas.parentNode) {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        if (this.overlay && this.overlay.parentNode) {\n            this.overlay.parentNode.removeChild(this.overlay);\n        }\n    }\n}\n\n/**\n * Initialize scanner with default options.\n *\n * @param {Object} options Scanner options\n * @returns {UniversalScanner} Scanner instance\n */\nexport const init = (options = {}) => {\n    return new UniversalScanner(options);\n};\n"],"names":["UniversalScanner","constructor","options","containerId","videoId","canvasId","resultCallback","errorCallback","scanTypes","timeout","isScanning","stream","video","canvas","context","sessionId","this","generateSessionId","scanAttempts","maxScanAttempts","startScanning","bind","stopScanning","processFrame","setupInterface","checkCameraSupport","error","handleError","message","container","document","getElementById","Error","createElement","id","setAttribute","style","width","height","display","getContext","willReadFrequently","appendChild","createScanOverlay","overlay","className","innerHTML","navigator","mediaDevices","getUserMedia","hasBarcodeDetector","window","updateStatus","facingMode","ideal","srcObject","play","videoWidth","videoHeight","scanLoop","getTracks","forEach","track","stop","setTimeout","debug","requestAnimationFrame","readyState","HAVE_ENOUGH_DATA","drawImage","detector","BarcodeDetector","formats","barcodes","detect","length","barcode","processScanResult","rawValue","format","detectQRCodeManually","imageData","getImageData","code","jsQR","scan","data","trim","scanType","includes","result","success","barcode_data","scan_type","timestamp","Date","now","showScanSuccess","sendScanToServer","handleScanError","barcodeData","request","methodname","args","session_id","Ajax","call","empty_barcode","invalid_uuid","item_not_found","product_not_found","unknown_type","error_code","errorCode","statusElement","querySelector","textContent","target","classList","add","remove","Math","random","toString","substr","file","Promise","resolve","reject","reader","FileReader","onload","async","img","Image","src","e","onerror","readAsDataURL","destroy","parentNode","removeChild"],"mappings":"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"}