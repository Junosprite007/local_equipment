{"version":3,"file":"jsqr.min.js","sources":["../src/jsqr.js"],"sourcesContent":["// JsQR library wrapper for Moodle AMD\n// This file is part of FLIP Plugins for Moodle\n\n/**\n * jsQR library for QR code detection\n * @module local_equipment/jsqr\n * @copyright 2024 onwards Joshua Kirby <josh@funlearningcompany.com>\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n// Simplified jsQR implementation for QR code detection\n// This is a lightweight version focused on basic QR code detection\n\nexport default class jsQR {\n    /**\n     * Scan image data for QR codes\n     * @param {Uint8ClampedArray} data Image data\n     * @param {number} width Image width\n     * @param {number} height Image height\n     * @returns {Object|null} QR code result or null\n     */\n    static scan(data, width, height) {\n        // This is a simplified implementation\n        // In a production environment, you would use the full jsQR library\n\n        try {\n            // Basic pattern detection for QR codes\n            const result = this.detectQRPattern(data, width, height);\n\n            if (result) {\n                return {\n                    data: result.data,\n                    location: result.location\n                };\n            }\n\n            return null;\n        } catch (error) {\n            // QR detection error - return null silently\n            return null;\n        }\n    }\n\n    /**\n     * Simplified QR pattern detection\n     * @param {Uint8ClampedArray} data Image data\n     * @param {number} width Image width\n     * @param {number} height Image height\n     * @returns {Object|null} Detection result\n     */\n    static detectQRPattern(data, width, height) {\n        // This is a very basic implementation\n        // Real jsQR would do sophisticated pattern matching\n\n        // Look for high contrast patterns that might indicate QR codes\n        const threshold = 128;\n        let darkPixels = 0;\n        let lightPixels = 0;\n        let patterns = 0;\n\n        // Sample pixels across the image\n        for (let y = 0; y < height; y += 10) {\n            for (let x = 0; x < width; x += 10) {\n                const index = (y * width + x) * 4;\n                const gray = (data[index] + data[index + 1] + data[index + 2]) / 3;\n\n                if (gray < threshold) {\n                    darkPixels++;\n                } else {\n                    lightPixels++;\n                }\n\n                // Look for alternating patterns (simplified)\n                if (x > 0 && y > 0) {\n                    const prevIndex = (y * width + (x - 10)) * 4;\n                    const prevGray = (data[prevIndex] + data[prevIndex + 1] + data[prevIndex + 2]) / 3;\n\n                    if ((gray < threshold && prevGray >= threshold) ||\n                        (gray >= threshold && prevGray < threshold)) {\n                        patterns++;\n                    }\n                }\n            }\n        }\n\n        // Very basic heuristic - if we have enough contrast and patterns,\n        // assume there might be a QR code\n        const totalPixels = darkPixels + lightPixels;\n        const contrastRatio = Math.min(darkPixels, lightPixels) / totalPixels;\n        const patternDensity = patterns / totalPixels;\n\n        if (contrastRatio > 0.2 && patternDensity > 0.1) {\n            // This is a placeholder - real implementation would decode the actual data\n            // For now, we'll rely on the browser's BarcodeDetector API when available\n            return null;\n        }\n\n        return null;\n    }\n\n    /**\n     * Check if jsQR is supported (always true for this simplified version)\n     * @returns {boolean} Always true\n     */\n    static isSupported() {\n        return true;\n    }\n}\n\n/**\n * Export the main scan function for compatibility\n * @param {Uint8ClampedArray} data Image data\n * @param {number} width Image width\n * @param {number} height Image height\n * @returns {Object|null} QR code result or null\n */\nexport const scan = (data, width, height) => {\n    return jsQR.scan(data, width, height);\n};\n"],"names":["jsQR","data","width","height","result","this","detectQRPattern","location","error","darkPixels","lightPixels","y","x","index","gray","prevIndex","prevGray","patterns","totalPixels","Math","min","scan"],"mappings":";;;;;;;MAaqBA,iBAQLC,KAAMC,MAAOC,kBAMXC,OAASC,KAAKC,gBAAgBL,KAAMC,MAAOC,eAE7CC,OACO,CACHH,KAAMG,OAAOH,KACbM,SAAUH,OAAOG,UAIlB,KACT,MAAOC,cAEE,6BAWQP,KAAMC,MAAOC,YAM5BM,WAAa,EACbC,YAAc,MAIb,IAAIC,EAAI,EAAGA,EAAIR,OAAQQ,GAAK,OACxB,IAAIC,EAAI,EAAGA,EAAIV,MAAOU,GAAK,GAAI,OAC1BC,MAA0B,GAAjBF,EAAIT,MAAQU,GACrBE,MAAQb,KAAKY,OAASZ,KAAKY,MAAQ,GAAKZ,KAAKY,MAAQ,IAAM,KAE7DC,KAXM,IAYNL,aAEAC,cAIAE,EAAI,GAAKD,EAAI,EAAG,OACVI,UAAqC,GAAxBJ,EAAIT,OAASU,EAAI,KAC9BI,UAAYf,KAAKc,WAAad,KAAKc,UAAY,GAAKd,KAAKc,UAAY,IAAM,GAE5ED,KAtBC,KAsBmBE,UAtBnB,KAuBDF,MAvBC,KAuBoBE,SAvBpB,MAwBFC,SAQVC,YAAcT,WAAaC,YACXS,KAAKC,IAAIX,WAAYC,oBAMhC,iCAWJ,8CAWK,CAACT,KAAMC,MAAOC,SACvBH,KAAKqB,KAAKpB,KAAMC,MAAOC"}